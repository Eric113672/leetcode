/*
* @Author: lishuang
* @Date:   2022/3/14 15:14
 */

package main

/*
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

示例 1：

输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]

解题思路
简明扼要，做这个题三步走
对所有数字异或,一样的数字抵消,出现一次的两个数字异或运算后必定不为 0;
用 lowbit得到一个二进制位最右边一位为1的数字 mask，也就是两者出现不等的地方，异或运算，相同为 0，不同为 1
mask 和数组的每个数字做与运算，等于 00 的分为一组，等于 mask 的分为一组，这同时也将两个不一样的数字分开了
PS：可能有朋友看不明白，我在这细说一下。得到的 temp是或运算的结果，也就是两个不同的数做或运算得到的结果，lowbit 是二进制表达式中最低位的1所对应的值，我们拿到这个lowbit，就知道这个位置是 1，
这两个数字做或运算 相同为 0，不同为 1，那就说明在这出现不同了，那这两个数字必定是一个为 1，一个为 0，不可能同时为 0 或 1。最后我们去和 mask 做与运算，由于其他数字都是成对出现，
这两个数字肯定是进入同一组的，你不可能同一个 num 去和 mask 做与运算出现两者结果吧，接下来两个相同的数字做或运算肯定是为 0 的，最后这一组只剩下一个数，而另一个到了另一组。

PS: 大白话讲 lowbit
求负数的二进制的步骤：给定一个数，比如 12，我们能求得它的二进制 1100，如何求 −12 的二进制？实际上二进制前面有个符号位，
正数前面符号位是 0，负数前面符号位是 1，12 的二进制实际上是 0110001100，那么求 −12 的二进制有两步：

首先把符号位从 0 改成 1，然后对 12 每位取反。变成 1001110011
最后 +1，即 10011+110011+1 = 1010010100，这就是 −12 的二进制
再细节点：那么给定一个数字 x，它的第 k 位为 1，0～k-1位都为 0，对它进行取反，也就是 0 变 1，1 变 0的操作，
得到 ～x 的二进制表示中，第 k位为 0 ，第 0 至第 k−1 位都为 1。再将 ～x 进行加 1 操作，
～x+1 的第 k 位变为 1，0～k-1位又都变为 0 了。实际上这就是我们求负数的过程，那么我们也就得到了一串 xxxxx10000xxxxx10000 这样的结果
（xxxxxxxxxx 是和正数对应的相反的哦），它再去和正数做与运算，我们就能得到lowbit 了。

lowbit=x\&(～x+1) = x\&(-x)lowbit=x&(～x+1)=x&(−x)
*/

func singleNumbers(nums []int) []int {
	var a int
	for i := range nums {
		a ^= nums[i]
	}
	mask := a & (-a)
	res := make([]int, 2)
	for _, v := range nums {
		if (v & mask) == 0 {
			res[0] ^= v
		} else {
			res[1] ^= v
		}
	}
	return res
}
